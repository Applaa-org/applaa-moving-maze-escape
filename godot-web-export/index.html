<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Moving Maze Escape - Time Challenge</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 4/3;
            background: #0a0a1a;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(0, 200, 255, 0.3), inset 0 0 60px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            border: 2px solid #00d4ff;
            z-index: 10;
        }

        #hud.visible {
            display: flex;
        }

        .hud-item {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #00d4ff;
        }

        #timer {
            color: #ff6b6b;
            font-size: 24px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        #highScoreHud {
            color: #ffd700;
            font-size: 16px;
        }

        /* Start Screen */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, rgba(10, 10, 26, 0.95) 0%, rgba(15, 52, 96, 0.95) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
        }

        #startScreen.hidden {
            display: none;
        }

        .game-title {
            font-size: clamp(28px, 6vw, 48px);
            color: #00d4ff;
            text-shadow: 0 0 20px #00d4ff, 0 0 40px #00d4ff;
            margin-bottom: 10px;
            text-align: center;
            animation: glow 2s ease-in-out infinite alternate;
        }

        .game-subtitle {
            font-size: clamp(16px, 3vw, 24px);
            color: #ff6b6b;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #ff6b6b;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px #00d4ff, 0 0 40px #00d4ff; }
            to { text-shadow: 0 0 30px #00d4ff, 0 0 60px #00d4ff, 0 0 80px #00d4ff; }
        }

        .instructions {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00d4ff;
            margin-bottom: 20px;
            max-width: 400px;
            text-align: center;
        }

        .instructions h3 {
            color: #ffd700;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .instructions p {
            color: #ccc;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .instructions .warning {
            color: #ff6b6b;
            font-weight: bold;
        }

        .high-score-display {
            background: rgba(255, 215, 0, 0.1);
            padding: 15px 25px;
            border-radius: 8px;
            border: 2px solid #ffd700;
            margin-bottom: 20px;
            text-align: center;
        }

        .high-score-display h4 {
            color: #ffd700;
            font-size: 18px;
            margin-bottom: 5px;
        }

        .high-score-display p {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
        }

        .player-name-input {
            margin-bottom: 20px;
            text-align: center;
        }

        .player-name-input label {
            color: #00d4ff;
            font-size: 16px;
            display: block;
            margin-bottom: 8px;
        }

        .player-name-input input {
            padding: 10px 20px;
            font-size: 16px;
            border: 2px solid #00d4ff;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            text-align: center;
            width: 200px;
        }

        .player-name-input input:focus {
            outline: none;
            box-shadow: 0 0 15px #00d4ff;
        }

        .btn {
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn-start {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .btn-start:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
        }

        .btn-close {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }

        .btn-close:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.8);
        }

        .btn-restart {
            background: linear-gradient(135deg, #44ff44, #00cc00);
            color: #000;
        }

        .btn-menu {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }

        /* Game Over / Victory Screen */
        #endScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
        }

        #endScreen.visible {
            display: flex;
        }

        .end-title {
            font-size: clamp(32px, 8vw, 56px);
            margin-bottom: 20px;
            text-align: center;
        }

        .victory {
            color: #44ff44;
            text-shadow: 0 0 30px #44ff44;
        }

        .defeat {
            color: #ff4444;
            text-shadow: 0 0 30px #ff4444;
        }

        .end-message {
            color: #fff;
            font-size: 20px;
            margin-bottom: 10px;
        }

        .new-high-score {
            color: #ffd700;
            font-size: 24px;
            font-weight: bold;
            animation: glow 0.5s ease-in-out infinite alternate;
            margin-bottom: 20px;
        }

        .score-display {
            color: #00d4ff;
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 30px;
        }

        .button-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 50;
        }

        #mobileControls.visible {
            display: block;
        }

        .control-grid {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 212, 255, 0.3);
            border: 2px solid #00d4ff;
            border-radius: 10px;
            color: #fff;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .control-btn:active {
            background: rgba(0, 212, 255, 0.6);
            transform: scale(0.95);
        }

        .control-btn.up { grid-column: 2; grid-row: 1; }
        .control-btn.left { grid-column: 1; grid-row: 2; }
        .control-btn.right { grid-column: 3; grid-row: 2; }
        .control-btn.down { grid-column: 2; grid-row: 3; }

        /* Top Scores List */
        .top-scores {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ffd700;
            margin-top: 15px;
            max-width: 300px;
        }

        .top-scores h4 {
            color: #ffd700;
            font-size: 16px;
            margin-bottom: 10px;
            text-align: center;
        }

        .top-scores ol {
            color: #fff;
            padding-left: 25px;
        }

        .top-scores li {
            margin-bottom: 5px;
            font-size: 14px;
        }

        /* Responsive */
        @media (max-width: 600px) {
            #hud {
                padding: 8px 12px;
            }
            .hud-item {
                font-size: 14px;
            }
            #timer {
                font-size: 18px;
            }
            .btn {
                padding: 12px 25px;
                font-size: 16px;
            }
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            .control-grid {
                grid-template-columns: 50px 50px 50px;
                grid-template-rows: 50px 50px 50px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD -->
        <div id="hud">
            <div class="hud-item" id="levelDisplay">Level 1</div>
            <div class="hud-item" id="timer">30</div>
            <div class="hud-item" id="highScoreHud">Best: 0</div>
        </div>

        <!-- Start Screen -->
        <div id="startScreen">
            <h1 class="game-title">üåÄ Moving Maze Escape</h1>
            <p class="game-subtitle">‚è±Ô∏è Time Challenge</p>
            
            <div class="high-score-display">
                <h4>üèÜ High Score</h4>
                <p id="highScoreDisplay">0</p>
            </div>

            <div class="instructions">
                <h3>üìã How to Play</h3>
                <p>Navigate through the shifting maze to reach the <span style="color:#44ff44">EXIT</span></p>
                <p>Use <strong>Arrow Keys</strong> or <strong>Touch Controls</strong> to move</p>
                <p class="warning">‚ö†Ô∏è Touching walls resets your position!</p>
                <p class="warning">‚è∞ Beat the clock before time runs out!</p>
            </div>

            <div class="player-name-input">
                <label for="playerName">Enter Your Name:</label>
                <input type="text" id="playerName" maxlength="15" placeholder="Player">
            </div>

            <div id="topScoresStart" class="top-scores" style="display: none;">
                <h4>üèÖ Top Scores</h4>
                <ol id="topScoresListStart"></ol>
            </div>

            <div class="button-row">
                <button class="btn btn-start" id="startBtn">üéÆ Start Game</button>
                <button class="btn btn-close" id="closeBtn">‚úñ Close</button>
            </div>
        </div>

        <!-- End Screen -->
        <div id="endScreen">
            <h1 class="end-title" id="endTitle">Game Over</h1>
            <p class="end-message" id="endMessage"></p>
            <p class="new-high-score" id="newHighScore" style="display: none;">üéâ NEW HIGH SCORE! üéâ</p>
            <p class="score-display" id="finalScore">Score: 0</p>
            
            <div id="topScoresEnd" class="top-scores">
                <h4>üèÖ Top Scores</h4>
                <ol id="topScoresListEnd"></ol>
            </div>

            <div class="button-row">
                <button class="btn btn-restart" id="restartBtn">üîÑ Play Again</button>
                <button class="btn btn-menu" id="menuBtn">üìã Main Menu</button>
                <button class="btn btn-close" id="closeBtn2">‚úñ Close</button>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobileControls">
            <div class="control-grid">
                <div class="control-btn up" data-dir="up">‚ñ≤</div>
                <div class="control-btn left" data-dir="left">‚óÄ</div>
                <div class="control-btn right" data-dir="right">‚ñ∂</div>
                <div class="control-btn down" data-dir="down">‚ñº</div>
            </div>
        </div>
    </div>

    <script>
        // ==================== GAME CONFIGURATION ====================
        const CONFIG = {
            GAME_ID: 'moving-maze-escape',
            PLAYER_SIZE: 16,
            PLAYER_SPEED: 4,
            WALL_THICKNESS: 20,
            TIMER_DURATION: 45,
            WALL_MOVE_SPEED: 0.8,
            WALL_MOVE_RANGE: 40,
            COLORS: {
                background: '#0a0a1a',
                wall: '#4a90d9',
                wallGlow: 'rgba(74, 144, 217, 0.5)',
                player: '#ff6b6b',
                playerGlow: 'rgba(255, 107, 107, 0.6)',
                exit: '#44ff44',
                exitGlow: 'rgba(68, 255, 68, 0.5)',
                path: '#1a1a3a'
            }
        };

        // ==================== SOUND SYSTEM ====================
        class SoundManager {
            constructor() {
                this.audioContext = null;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (e) {
                    console.warn('Audio not supported');
                }
            }

            playTone(frequency, duration, type = 'sine', volume = 0.3) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            playStart() {
                this.playTone(523, 0.15, 'sine', 0.3);
                setTimeout(() => this.playTone(659, 0.15, 'sine', 0.3), 100);
                setTimeout(() => this.playTone(784, 0.2, 'sine', 0.3), 200);
            }

            playHit() {
                this.playTone(200, 0.2, 'sawtooth', 0.4);
                setTimeout(() => this.playTone(150, 0.15, 'sawtooth', 0.3), 50);
            }

            playSuccess() {
                this.playTone(523, 0.15, 'sine', 0.3);
                setTimeout(() => this.playTone(659, 0.15, 'sine', 0.3), 100);
                setTimeout(() => this.playTone(784, 0.15, 'sine', 0.3), 200);
                setTimeout(() => this.playTone(1047, 0.3, 'sine', 0.4), 300);
            }

            playGameOver() {
                this.playTone(392, 0.3, 'sawtooth', 0.3);
                setTimeout(() => this.playTone(330, 0.3, 'sawtooth', 0.3), 200);
                setTimeout(() => this.playTone(262, 0.5, 'sawtooth', 0.3), 400);
            }

            playTick() {
                this.playTone(880, 0.05, 'sine', 0.1);
            }
        }

        // ==================== STORAGE SYSTEM ====================
        class StorageManager {
            constructor(gameId) {
                this.gameId = gameId;
                this.data = this.loadData();
            }

            loadData() {
                try {
                    const stored = localStorage.getItem(`applaa-game-data-${this.gameId}`);
                    if (stored) {
                        return JSON.parse(stored);
                    }
                } catch (e) {
                    console.warn('Failed to load game data:', e);
                }
                return {
                    gameId: this.gameId,
                    scores: [],
                    highScore: 0,
                    lastPlayerName: '',
                    gameProgress: {},
                    customData: {}
                };
            }

            saveData() {
                try {
                    localStorage.setItem(`applaa-game-data-${this.gameId}`, JSON.stringify(this.data));
                    // Also notify parent window if in iframe
                    this.notifyParent('applaa-game-data-saved', this.data);
                } catch (e) {
                    console.warn('Failed to save game data:', e);
                }
            }

            saveScore(playerName, score) {
                const scoreEntry = {
                    playerName: playerName || 'Player',
                    score: score,
                    timestamp: new Date().toISOString()
                };
                
                this.data.scores.unshift(scoreEntry);
                this.data.scores = this.data.scores.slice(0, 10); // Keep top 10
                this.data.scores.sort((a, b) => b.score - a.score);
                
                if (score > this.data.highScore) {
                    this.data.highScore = score;
                }
                
                this.data.lastPlayerName = playerName;
                this.saveData();
                
                // Notify parent window
                this.notifyParent('applaa-game-save-score', { playerName, score });
                
                return score > this.data.highScore;
            }

            getHighScore() {
                return this.data.highScore;
            }

            getTopScores(limit = 5) {
                return this.data.scores.slice(0, limit);
            }

            getLastPlayerName() {
                return this.data.lastPlayerName || '';
            }

            notifyParent(type, data) {
                try {
                    window.parent.postMessage({
                        type: type,
                        gameId: this.gameId,
                        data: data
                    }, '*');
                } catch (e) {
                    // Not in iframe or cross-origin
                }
            }

            requestParentData() {
                this.notifyParent('applaa-game-load-data', {});
            }
        }

        // ==================== MAZE GENERATOR ====================
        class MazeGenerator {
            constructor(cols, rows) {
                this.cols = cols;
                this.rows = rows;
            }

            generate() {
                // Initialize grid with walls
                const grid = [];
                for (let y = 0; y < this.rows; y++) {
                    grid[y] = [];
                    for (let x = 0; x < this.cols; x++) {
                        grid[y][x] = 1; // Wall
                    }
                }

                // Recursive backtracking maze generation
                const stack = [];
                const startX = 1;
                const startY = 1;
                
                grid[startY][startX] = 0;
                stack.push({ x: startX, y: startY });

                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    const neighbors = this.getUnvisitedNeighbors(grid, current.x, current.y);

                    if (neighbors.length === 0) {
                        stack.pop();
                    } else {
                        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Remove wall between current and next
                        const wallX = current.x + (next.x - current.x) / 2;
                        const wallY = current.y + (next.y - current.y) / 2;
                        grid[wallY][wallX] = 0;
                        grid[next.y][next.x] = 0;
                        
                        stack.push(next);
                    }
                }

                // Ensure exit is accessible
                grid[this.rows - 2][this.cols - 2] = 0;
                grid[this.rows - 2][this.cols - 3] = 0;

                return grid;
            }

            getUnvisitedNeighbors(grid, x, y) {
                const neighbors = [];
                const directions = [
                    { dx: 0, dy: -2 },
                    { dx: 2, dy: 0 },
                    { dx: 0, dy: 2 },
                    { dx: -2, dy: 0 }
                ];

                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    
                    if (nx > 0 && nx < this.cols - 1 && ny > 0 && ny < this.rows - 1) {
                        if (grid[ny][nx] === 1) {
                            neighbors.push({ x: nx, y: ny });
                        }
                    }
                }

                return neighbors;
            }
        }

        // ==================== MAIN GAME CLASS ====================
        class MovingMazeGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // UI Elements
                this.startScreen = document.getElementById('startScreen');
                this.endScreen = document.getElementById('endScreen');
                this.hud = document.getElementById('hud');
                this.mobileControls = document.getElementById('mobileControls');
                this.timerDisplay = document.getElementById('timer');
                this.levelDisplay = document.getElementById('levelDisplay');
                this.highScoreHud = document.getElementById('highScoreHud');
                this.playerNameInput = document.getElementById('playerName');
                
                // Managers
                this.sound = new SoundManager();
                this.storage = new StorageManager(CONFIG.GAME_ID);
                
                // Game state
                this.isRunning = false;
                this.isPaused = false;
                this.gameTime = 0;
                this.timer = CONFIG.TIMER_DURATION;
                this.score = 0;
                this.level = 1;
                this.lastTimestamp = 0;
                this.timerInterval = null;
                
                // Player
                this.player = { x: 0, y: 0 };
                this.playerStart = { x: 0, y: 0 };
                
                // Maze
                this.maze = [];
                this.walls = [];
                this.cellSize = 0;
                this.mazeOffsetX = 0;
                this.mazeOffsetY = 0;
                
                // Exit
                this.exit = { x: 0, y: 0, width: 0, height: 0 };
                
                // Controls
                this.keys = {
                    up: false,
                    down: false,
                    left: false,
                    right: false
                };
                
                // Initialize
                this.init();
            }

            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.loadSavedData();
                this.showStartScreen();
                
                // Check for mobile
                if ('ontouchstart' in window) {
                    this.mobileControls.classList.add('visible');
                }
                
                // Request data from parent (Applaa)
                this.storage.requestParentData();
                
                // Listen for parent messages
                window.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'applaa-game-data-loaded') {
                        if (event.data.data) {
                            this.storage.data = { ...this.storage.data, ...event.data.data };
                            this.loadSavedData();
                        }
                    }
                });
            }

            loadSavedData() {
                // Initialize high score display to 0 first
                document.getElementById('highScoreDisplay').textContent = '0';
                this.highScoreHud.textContent = 'Best: 0';
                
                // Load from storage
                const highScore = this.storage.getHighScore();
                const lastPlayer = this.storage.getLastPlayerName();
                const topScores = this.storage.getTopScores(5);
                
                // Update displays with actual values
                document.getElementById('highScoreDisplay').textContent = highScore.toLocaleString();
                this.highScoreHud.textContent = `Best: ${highScore}`;
                
                // Pre-fill player name
                if (lastPlayer) {
                    this.playerNameInput.value = lastPlayer;
                }
                
                // Display top scores on start screen
                this.displayTopScores(topScores, 'topScoresListStart', 'topScoresStart');
            }

            displayTopScores(scores, listId, containerId) {
                const list = document.getElementById(listId);
                const container = document.getElementById(containerId);
                
                if (scores.length === 0) {
                    container.style.display = 'none';
                    return;
                }
                
                container.style.display = 'block';
                list.innerHTML = '';
                
                scores.forEach(entry => {
                    const li = document.createElement('li');
                    li.textContent = `${entry.playerName}: ${entry.score}`;
                    list.appendChild(li);
                });
            }

            resizeCanvas() {
                const container = document.getElementById('gameContainer');
                const rect = container.getBoundingClientRect();
                
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Keyboard controls
                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                // Buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('restartBtn').addEventListener('click', () => this.restartGame());
                document.getElementById('menuBtn').addEventListener('click', () => this.showStartScreen());
                document.getElementById('closeBtn').addEventListener('click', () => this.closeGame());
                document.getElementById('closeBtn2').addEventListener('click', () => this.closeGame());
                
                // Mobile controls
                const controlBtns = document.querySelectorAll('.control-btn');
                controlBtns.forEach(btn => {
                    const dir = btn.dataset.dir;
                    
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.keys[dir] = true;
                    });
                    
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.keys[dir] = false;
                    });
                    
                    btn.addEventListener('mousedown', () => this.keys[dir] = true);
                    btn.addEventListener('mouseup', () => this.keys[dir] = false);
                    btn.addEventListener('mouseleave', () => this.keys[dir] = false);
                });
            }

            handleKeyDown(e) {
                if (!this.isRunning) return;
                
                switch (e.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        this.keys.up = true;
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        this.keys.down = true;
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        this.keys.left = true;
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        this.keys.right = true;
                        e.preventDefault();
                        break;
                    case 'Escape':
                        this.togglePause();
                        break;
                }
            }

            handleKeyUp(e) {
                switch (e.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        this.keys.up = false;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        this.keys.down = false;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        this.keys.left = false;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        this.keys.right = false;
                        break;
                }
            }

            togglePause() {
                this.isPaused = !this.isPaused;
            }

            startGame() {
                this.sound.init();
                this.sound.playStart();
                
                this.startScreen.classList.add('hidden');
                this.endScreen.classList.remove('visible');
                this.hud.classList.add('visible');
                
                if ('ontouchstart' in window) {
                    this.mobileControls.classList.add('visible');
                }
                
                this.initGame();
            }

            initGame() {
                this.timer = CONFIG.TIMER_DURATION;
                this.score = 0;
                this.level = 1;
                this.gameTime = 0;
                this.isRunning = true;
                this.isPaused = false;
                
                // Reset keys
                this.keys = { up: false, down: false, left: false, right: false };
                
                // Generate maze
                this.generateMaze();
                
                // Reset player position
                this.resetPlayerPosition();
                
                // Update HUD
                this.updateHUD();
                
                // Start timer
                this.startTimer();
                
                // Start game loop
                this.lastTimestamp = performance.now();
                requestAnimationFrame((ts) => this.gameLoop(ts));
            }

            generateMaze() {
                const mazeWidth = this.canvas.width * 0.9;
                const mazeHeight = this.canvas.height * 0.75;
                
                // Calculate cell size and maze dimensions
                const cols = 15;
                const rows = 11;
                this.cellSize = Math.min(mazeWidth / cols, mazeHeight / rows);
                
                const actualMazeWidth = cols * this.cellSize;
                const actualMazeHeight = rows * this.cellSize;
                
                this.mazeOffsetX = (this.canvas.width - actualMazeWidth) / 2;
                this.mazeOffsetY = (this.canvas.height - actualMazeHeight) / 2 + 20;
                
                // Generate maze grid
                const generator = new MazeGenerator(cols, rows);
                this.maze = generator.generate();
                
                // Create wall objects with movement properties
                this.walls = [];
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        if (this.maze[y][x] === 1) {
                            const wall = {
                                baseX: this.mazeOffsetX + x * this.cellSize,
                                baseY: this.mazeOffsetY + y * this.cellSize,
                                x: this.mazeOffsetX + x * this.cellSize,
                                y: this.mazeOffsetY + y * this.cellSize,
                                width: this.cellSize,
                                height: this.cellSize,
                                moveType: Math.random() > 0.7 ? (Math.random() > 0.5 ? 'horizontal' : 'vertical') : 'none',
                                movePhase: Math.random() * Math.PI * 2,
                                moveSpeed: CONFIG.WALL_MOVE_SPEED + Math.random() * 0.5,
                                moveRange: CONFIG.WALL_MOVE_RANGE * (0.5 + Math.random() * 0.5)
                            };
                            this.walls.push(wall);
                        }
                    }
                }
                
                // Set player start position
                this.playerStart.x = this.mazeOffsetX + 1.5 * this.cellSize;
                this.playerStart.y = this.mazeOffsetY + 1.5 * this.cellSize;
                
                // Set exit position
                this.exit = {
                    x: this.mazeOffsetX + (cols - 2) * this.cellSize,
                    y: this.mazeOffsetY + (rows - 2) * this.cellSize,
                    width: this.cellSize,
                    height: this.cellSize
                };
            }

            resetPlayerPosition() {
                this.player.x = this.playerStart.x;
                this.player.y = this.playerStart.y;
            }

            startTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                this.timerInterval = setInterval(() => {
                    if (!this.isRunning || this.isPaused) return;
                    
                    this.timer--;
                    this.timerDisplay.textContent = this.timer;
                    
                    if (this.timer <= 10) {
                        this.timerDisplay.style.color = '#ff4444';
                        this.sound.playTick();
                    }
                    
                    if (this.timer <= 0) {
                        this.gameOver(false);
                    }
                }, 1000);
            }

            updateHUD() {
                this.timerDisplay.textContent = this.timer;
                this.levelDisplay.textContent = `Level ${this.level}`;
                this.highScoreHud.textContent = `Best: ${this.storage.getHighScore()}`;
                this.timerDisplay.style.color = '#ff6b6b';
            }

            gameLoop(timestamp) {
                if (!this.isRunning) return;
                
                const deltaTime = (timestamp - this.lastTimestamp) / 1000;
                this.lastTimestamp = timestamp;
                
                if (!this.isPaused) {
                    this.gameTime += deltaTime;
                    this.update(deltaTime);
                }
                
                this.render();
                
                requestAnimationFrame((ts) => this.gameLoop(ts));
            }

            update(deltaTime) {
                // Update wall positions
                this.updateWalls();
                
                // Move player
                this.movePlayer(deltaTime);
                
                // Check collisions
                this.checkCollisions();
                
                // Check exit
                this.checkExit();
            }

            updateWalls() {
                for (const wall of this.walls) {
                    if (wall.moveType === 'horizontal') {
                        wall.x = wall.baseX + Math.sin(this.gameTime * wall.moveSpeed + wall.movePhase) * wall.moveRange;
                    } else if (wall.moveType === 'vertical') {
                        wall.y = wall.baseY + Math.sin(this.gameTime * wall.moveSpeed + wall.movePhase) * wall.moveRange;
                    }
                }
            }

            movePlayer(deltaTime) {
                const speed = CONFIG.PLAYER_SPEED * 60 * deltaTime;
                
                if (this.keys.up) {
                    this.player.y -= speed;
                }
                if (this.keys.down) {
                    this.player.y += speed;
                }
                if (this.keys.left) {
                    this.player.x -= speed;
                }
                if (this.keys.right) {
                    this.player.x += speed;
                }
                
                // Keep player in bounds
                const halfSize = CONFIG.PLAYER_SIZE / 2;
                this.player.x = Math.max(halfSize, Math.min(this.canvas.width - halfSize, this.player.x));
                this.player.y = Math.max(halfSize, Math.min(this.canvas.height - halfSize, this.player.y));
            }

            checkCollisions() {
                const playerRect = {
                    x: this.player.x - CONFIG.PLAYER_SIZE / 2,
                    y: this.player.y - CONFIG.PLAYER_SIZE / 2,
                    width: CONFIG.PLAYER_SIZE,
                    height: CONFIG.PLAYER_SIZE
                };
                
                for (const wall of this.walls) {
                    if (this.rectIntersect(playerRect, wall)) {
                        this.sound.playHit();
                        this.resetPlayerPosition();
                        return;
                    }
                }
            }

            checkExit() {
                const playerRect = {
                    x: this.player.x - CONFIG.PLAYER_SIZE / 2,
                    y: this.player.y - CONFIG.PLAYER_SIZE / 2,
                    width: CONFIG.PLAYER_SIZE,
                    height: CONFIG.PLAYER_SIZE
                };
                
                const exitCenter = {
                    x: this.exit.x + this.exit.width / 2,
                    y: this.exit.y + this.exit.height / 2
                };
                
                const distance = Math.sqrt(
                    Math.pow(this.player.x - exitCenter.x, 2) +
                    Math.pow(this.player.y - exitCenter.y, 2)
                );
                
                if (distance < this.cellSize / 2) {
                    this.gameOver(true);
                }
            }

            rectIntersect(r1, r2) {
                return r1.x < r2.x + r2.width &&
                       r1.x + r1.width > r2.x &&
                       r1.y < r2.y + r2.height &&
                       r1.y + r1.height > r2.y;
            }

            gameOver(victory) {
                this.isRunning = false;
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                // Calculate score
                if (victory) {
                    this.score = Math.round(this.timer * 100 + 500);
                    this.sound.playSuccess();
                } else {
                    this.score = Math.round((CONFIG.TIMER_DURATION - this.timer) * 10);
                    this.sound.playGameOver();
                }
                
                // Save score
                const playerName = this.playerNameInput.value.trim() || 'Player';
                const isNewHighScore = this.score > this.storage.getHighScore();
                this.storage.saveScore(playerName, this.score);
                
                // Show end screen
                this.showEndScreen(victory, isNewHighScore);
            }

            showEndScreen(victory, isNewHighScore) {
                const endTitle = document.getElementById('endTitle');
                const endMessage = document.getElementById('endMessage');
                const newHighScore = document.getElementById('newHighScore');
                const finalScore = document.getElementById('finalScore');
                
                if (victory) {
                    endTitle.textContent = 'üéâ You Escaped!';
                    endTitle.className = 'end-title victory';
                    endMessage.textContent = `Time remaining: ${this.timer} seconds`;
                } else {
                    endTitle.textContent = '‚è∞ Time Up!';
                    endTitle.className = 'end-title defeat';
                    endMessage.textContent = 'The maze claimed another victim...';
                }
                
                finalScore.textContent = `Score: ${this.score}`;
                
                if (isNewHighScore && this.score > 0) {
                    newHighScore.style.display = 'block';
                } else {
                    newHighScore.style.display = 'none';
                }
                
                // Display top scores
                const topScores = this.storage.getTopScores(5);
                this.displayTopScores(topScores, 'topScoresListEnd', 'topScoresEnd');
                
                // Update HUD high score
                this.highScoreHud.textContent = `Best: ${this.storage.getHighScore()}`;
                document.getElementById('highScoreDisplay').textContent = this.storage.getHighScore().toLocaleString();
                
                this.hud.classList.remove('visible');
                this.mobileControls.classList.remove('visible');
                this.endScreen.classList.add('visible');
            }

            showStartScreen() {
                this.isRunning = false;
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                this.endScreen.classList.remove('visible');
                this.hud.classList.remove('visible');
                this.mobileControls.classList.remove('visible');
                this.startScreen.classList.remove('hidden');
                
                // Refresh saved data display
                this.loadSavedData();
            }

            restartGame() {
                this.endScreen.classList.remove('visible');
                this.hud.classList.add('visible');
                
                if ('ontouchstart' in window) {
                    this.mobileControls.classList.add('visible');
                }
                
                this.sound.playStart();
                this.initGame();
            }

            closeGame() {
                // Try to close window or notify parent
                try {
                    window.parent.postMessage({ type: 'applaa-game-close' }, '*');
                } catch (e) {
                    // Ignore
                }
                
                // If in standalone, show message
                this.showStartScreen();
            }

            render() {
                const ctx = this.ctx;
                
                // Clear canvas
                ctx.fillStyle = CONFIG.COLORS.background;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw path background
                ctx.fillStyle = CONFIG.COLORS.path;
                ctx.fillRect(
                    this.mazeOffsetX,
                    this.mazeOffsetY,
                    15 * this.cellSize,
                    11 * this.cellSize
                );
                
                // Draw exit
                this.drawExit();
                
                // Draw walls
                this.drawWalls();
                
                // Draw player
                this.drawPlayer();
                
                // Draw pause overlay
                if (this.isPaused) {
                    this.drawPauseOverlay();
                }
            }

            drawExit() {
                const ctx = this.ctx;
                const centerX = this.exit.x + this.exit.width / 2;
                const centerY = this.exit.y + this.exit.height / 2;
                
                // Glow effect
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, this.cellSize
                );
                gradient.addColorStop(0, CONFIG.COLORS.exit);
                gradient.addColorStop(0.5, CONFIG.COLORS.exitGlow);
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(
                    this.exit.x - this.cellSize / 2,
                    this.exit.y - this.cellSize / 2,
                    this.exit.width + this.cellSize,
                    this.exit.height + this.cellSize
                );
                
                // Exit marker
                ctx.fillStyle = CONFIG.COLORS.exit;
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.cellSize / 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Pulsing ring
                const pulse = Math.sin(this.gameTime * 3) * 0.3 + 0.7;
                ctx.strokeStyle = CONFIG.COLORS.exit;
                ctx.lineWidth = 3;
                ctx.globalAlpha = pulse;
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.cellSize / 2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // EXIT text
                ctx.fillStyle = '#000';
                ctx.font = `bold ${this.cellSize / 4}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('EXIT', centerX, centerY);
            }

            drawWalls() {
                const ctx = this.ctx;
                
                for (const wall of this.walls) {
                    // Wall glow for moving walls
                    if (wall.moveType !== 'none') {
                        ctx.shadowColor = '#ff6b6b';
                        ctx.shadowBlur = 10;
                    } else {
                        ctx.shadowColor = CONFIG.COLORS.wallGlow;
                        ctx.shadowBlur = 5;
                    }
                    
                    // Wall body
                    const gradient = ctx.createLinearGradient(
                        wall.x, wall.y,
                        wall.x + wall.width, wall.y + wall.height
                    );
                    
                    if (wall.moveType !== 'none') {
                        gradient.addColorStop(0, '#ff8888');
                        gradient.addColorStop(0.5, '#ff5555');
                        gradient.addColorStop(1, '#cc4444');
                    } else {
                        gradient.addColorStop(0, '#6ab0ff');
                        gradient.addColorStop(0.5, CONFIG.COLORS.wall);
                        gradient.addColorStop(1, '#3a70a9');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                    
                    // Wall border
                    ctx.strokeStyle = wall.moveType !== 'none' ? '#ffaaaa' : '#8ac0ff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
                    
                    ctx.shadowBlur = 0;
                }
            }

            drawPlayer() {
                const ctx = this.ctx;
                const size = CONFIG.PLAYER_SIZE;
                
                // Player glow
                ctx.shadowColor = CONFIG.COLORS.playerGlow;
                ctx.shadowBlur = 15;
                
                // Player body
                const gradient = ctx.createRadialGradient(
                    this.player.x, this.player.y, 0,
                    this.player.x, this.player.y, size
                );
                gradient.addColorStop(0, '#ffaaaa');
                gradient.addColorStop(0.5, CONFIG.COLORS.player);
                gradient.addColorStop(1, '#cc4444');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.player.x, this.player.y, size / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Player border
                ctx.strokeStyle = '#ffcccc';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Eyes
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.player.x - size / 5, this.player.y - size / 8, size / 8, 0, Math.PI * 2);
                ctx.arc(this.player.x + size / 5, this.player.y - size / 8, size / 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.player.x - size / 5, this.player.y - size / 8, size / 16, 0, Math.PI * 2);
                ctx.arc(this.player.x + size / 5, this.player.y - size / 8, size / 16, 0, Math.PI * 2);
                ctx.fill();
            }

            drawPauseOverlay() {
                const ctx = this.ctx;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
                
                ctx.font = '20px Arial';
                ctx.fillText('Press ESC to resume', this.canvas.width / 2, this.canvas.height / 2 + 50);
            }
        }

        // ==================== INITIALIZE GAME ====================
        window.addEventListener('load', () => {
            const game = new MovingMazeGame();
        });
    </script>
</body>
</html>